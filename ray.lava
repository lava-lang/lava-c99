import <math.h>;

struct Vec {
    f64 x, y, z;

    void add(Vec* v) {
        x += v.x; y += v.y; z += v.z;
    }

    void sub(Vec* v) {
        x -= v.x; y -= v.y; z -= v.z;
    }

    void mult(f64 m) {
        x *= m; y *= m; z *= m;
    }

    void div(f64 d) {
        x /= d; y /= d; z /= d;
    }

    void norm() {
        f64 m = x*x + y*y + z*z;
        m = c.sqrt(m);
        x /= m; y /= m; z /= m;
    }

    f64 dot(Vec* v) {
        return x * v.x + y * v.y + z * v.z;
    }
}

struct Ray {
    Vec o;
    Vec d;
}

struct Sphere {
    Vec c;
    f64 r;
    Vec col;

    void getNormal(Vec* out, Vec* p) {
        out.x = p.x;
        out.y = p.y;
        out.z = p.z;
        out.sub(c);
        out.div(r);
    }

    // if the discriminant of the intersection formula is a negative
    // or very small number, it does not intersect.
    bool intersects(Ray* ray) {
        Vec p = {0 ,0, 0};
        p = ray.o; //should mem copy
        p.sub(c);
        f64 b = 2 * p.dot(&ray.d);
        f64 c1 = p.dot(&p) - (r * r);
        f64 disc = b * b - 4 * c1;
        if (disc < 0.0001) {
            return false;
        } else {
            return true;
        }
    }

    f64 intersection(Ray* ray) {
        Vec p = {0 ,0, 0};
        p = ray.o; //should mem copy
        p.sub(c);
        f64 b = 2 * p.dot(&ray.d);
        f64 c1 = p.dot(&p) - (r * r);
        f64 disc = c.sqrt(b * b - 4 * c1);
        // solution point is the smaller point
        f64 t0 = -b-disc;
        f64 t1 = -b+disc;
        if (t0 < t1) {
            return t0;
        } else {
            return t1;
        }
    }
}

void clamp(Vec* col) {
    if (col.x > 255) {
        col.x = 255;
    } else if (col.x < 0) {
        col.x = 0;
    }
    if (col.y > 255) {
        col.y = 255;
    } else if (col.y < 0) {
        col.y = 0;
    }
    if (col.z > 255) {
        col.z = 255;
    } else if (col.z < 0) {
        col.z = 0;
    }
}

void drawPixel(Sphere* s, Vec* pixCol, Ray* ray, Sphere* light) {
    f64 t = s.intersection(ray); //returns new
    Vec temp = {0, 0, 0};
    //vector sln
    Vec sln = {0, 0, 0};
        //mult
    temp = ray.d;
    temp.mult(t); //temp has result of mult
        //add
    sln = ray.o;
    sln.add(&temp); //temp gets added to sln

    //vector l
    temp = light.c; //has light.c value
    Vec l = {0, 0, 0};
    temp.sub(&sln);
    l = temp;

    //vector n
    Vec n = {0, 0, 0};
    s.getNormal(&n, &sln); //result of getNormal is stored in n, and sln is not changed

    // dt is the amount of shading produced, determined
    // by Lambertian reflection equation
    n.norm(); //n is now normalised in place
    l.norm(); //l is now normalised in place
    f64 dt = l.dot(&n); //dt is the in place dot (with in) returning float

    Vec whiteTemp = {255, 255, 255}; //white
    whiteTemp.mult(dt);
    whiteTemp.add(&s.col);
    whiteTemp.mult(0.5);
    pixCol.x = whiteTemp.x;
    pixCol.y = whiteTemp.y;
    pixCol.z = whiteTemp.z;
    clamp(pixCol);
}

int main() {
    int h = 500;
    int w = 500;
    Vec bg = {16, 16, 16};

    //Light
    Vec lv = {1000, -1000, 0};
    Sphere light = {lv, 100};

    //Shpere 1
    Vec sv1 = {w * 0.5, h * 0.5, 50};
    Vec purple = {160, 32, 240};
    Sphere s1 = {sv1, 125, purple};

    //Sphere 2
    Vec sv2 = {w * 0.75, h * 0.75, 50};
    Vec red = {255, 0, 0};
    Sphere s2 = {sv2, 75, red};

    //Sphere 3
    Vec sv3 = {w * 0.25, h * 0.25, 10};
    Vec blue = {0, 0, 255};
    Sphere s3 = {sv3, 75, blue};

    c.FILE *output = fopen("out.ppm", "w");
    //PPM header
    c.fprintf(output, "P3\n%d %d 255\n", w, h);

    //intersection
    Vec pixCol = bg;
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            pixCol = bg;
            // a ray is sent from the current camera's pixel, out onto the scene
            // if the ray intersects, determine the point of intersection
            // and the direction of the reflected ray
            Vec v1 = {x, y, 0};
            Vec v2 = {0, 0, 1};
            Ray ray = {v1, v2};
            if (s3.intersects(&ray)) {
                drawPixel(&s3, &pixCol, &ray, &light);
            }
            if (s2.intersects(&ray)) {
                drawPixel(&s2, &pixCol, &ray, &light);
            }
            if (s1.intersects(&ray)) {
                drawPixel(&s1, &pixCol, &ray, &light);
            }
            c.fprintf(output, "%f %f %f\n", pixCol.x, pixCol.y, pixCol.z);
        }
    }
    c.fclose(output);
}